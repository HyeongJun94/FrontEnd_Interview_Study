## 🔸 용어 설명
**프로그램**

어떤 작업을 위해 운영체제 위에서 실행할 수 있는 파일



**프로세스**

운영체제 위에서 실행중인 프로그램



**프로세서**

프로세스가 동작될 수 있도록 하는 하드웨어(cpu)



**스레드**

프로세스 내에서 실행되는 여러 흐름의 단위

## 🔸 멀티 태스킹
멀티 태스킹은 다수의 작업이 CPU와 같은 자원을 나누어 사용하는 것을 말합니다. 

컴퓨터로 음악을 들으면서 웹 서핑도 하고 메신저를 사용할 수 있는 것이 모두 멀티 태스킹 덕분입니다.

아래 그림을 보시면 여러 프로세스가 동시에 실행되고 있는 것처럼 보입니다.
<p align = "center">
<img src="https://blog.kakaocdn.net/dn/b3X7c9/btrAQ6Tdurv/LgRorZ69gOmhM6J8IHn7kk/img.jpg"/>
</p>

하지만 CPU는 한번에 하나의 프로세스만 실행할 수 있습니다. 즉, 동시에 프로세스를 실행하는 것이 아니라, 재빠르게 프로세스들을 번갈아가며 실행하여 동시에 실행하는 것처럼 느끼게 하는 것입니다.

## 🔸 프로세스
프로세스가 전환될 때의 상태 변화에 대해 알아보도록 하겠습니다.
<p align = "center">
<img src="https://user-images.githubusercontent.com/17793440/166110282-75f8a609-9b67-42a7-a210-800549355f5c.png"/>
</p>

### 프로세스 상태

**new**

프로그램이 메모리에 올라가 프로세스가 되고, 운영체제에 의해 프로세스 제어 블럭(PCB)가 생성됩니다.



**ready**

PCB가 준비 큐에 들어가서 CPU에 할당될 때까지 차례를 기다립니다.



**running**

CPU 스케줄러에 의해 준비 상태의 프로세스가 실행상태가 됩니다.(디스패치)

시분할 시스템의 경우, 할당 받은 시간이 끝나면 interrupt가 발생하여 다시 ready 상태가 됩니다. 



**waiting**

입출력 요청이 발생하면 waiting 상태가 됩니다. 입출력 작업이 완료되면 ready 상태로 돌아갑니다.



**terminated**

프로세스가 작업을 모두 완료하면 terminated 상태가 됩니다. 메모리에 적재되었던 프로세스 정보와 프로세스 제어 블럭(PCB)이 제거됩니다.



**프로세스 제어 블럭이란?**

프로세스를 제어하기 위한 정보 모음으로, 프로세스 식별자, 상태, 다음에 실행할 명령어의 주소 등등을 담고 있습니다.

<br/>  
    
기존에 실행하던 프로세스에서 새로운 프로세스로 전환될 때, 기존 프로세스는 ready 상태로, 새로운 프로세스는 running 상태가 됩니다.  
그리고 기존 프로세스의 정보나 상태 값을 프로세스 제어 블럭에 저장하고, 새로운 프로세스의 프로세스 제어 블럭의 정보를 가져옵니다. 이 것을 Context Switching이라고 합니다.

<br/>  

### 프로세스 구조

프로세스의 구조 때문에 프로세스를 전환 할 때는 Context Switching 비용이 많이 듭니다.
<p align="center">
<img src="https://user-images.githubusercontent.com/17793440/166139880-f79a65fe-9bdd-41a3-83d2-3db30023b320.png" width="600px"/>
</p>

하나의 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받습니다.

**Code**

실행할 프로그램의 코드

**Data**

코드에서 선언한 전역 변수와 정적 변수가 저장되는 영역

**Stack**

호출된 함수, 지역 변수, 매개 변수, 리턴 값 등의 임시 데이터

**Heap**

동적으로 생성된 데이터







###  멀티 프로세스
한 프로세스가 독립적인 Stack, Data, Heap, Code를 가지고 있기 때문에, Context Switching 과정에서 오버헤드가 발생하여 성능 저하가 발생할 수 있습니다.

- 프로세스 간에 Context Switching이 발생하면 캐시에 있는 모든 데이터를 리셋하고 다시 캐시 정보를 불러와야 하기 때문에 많은 시간이 소요될 수 있습니다.

- 다른 프로세스의 정보를 이용하기 위해서는 통신이 필요합니다.



이러한 비효율을 줄이기 위해 스레드가 탄생합니다.
<br/><br/>

## 🔸 스레드
스레드는 한 프로세스 내에서 동작하는 흐름으로, 프로세스와는 조금 다른 구조를 가지고 있습니다.



**스레드 구조**

스레드는 Stack 영역만 별도로 할당받고, 프로세스의 Code, Data, Heap 영역은 공유합니다. 따라서 프로세스 내의 스레드들은 서로 자원들을 공유하며 실행될 수 있습니다.

<p align="center">
<img src="https://user-images.githubusercontent.com/17793440/166139989-53ad93d6-5afc-43c0-80b5-6c774f99c5ec.png" width="600px"/>
</p>

**멀티 스레드**

**장점**

프로세스의 자원과 메모리를 공유하기 때문에, Context Switching 비용이 적습니다.

자원 공유가 쉽습니다.

프로세스를 할당하는 것보다 스레드를 할당하는 것이 비용이 적습니다.

**단점**

구현이 어려우며, 여러 스레드 중 하나에 문제가 생긴 경우 전체 스레드에 영향을 줄 수 있습니다.

데이터 동기화에 신경을 써야 합니다.



크롬은 멀티 탭 구현에 멀티 프로세스를 선택하였고, 각 탭이 별도의 프로세스를 가집니다. 이를 통해 하나의 탭에 문제가 있어도 다른 탭이 종료되지 않습니다. 반면 익스플로러에서는 멀티 탭 구현에 멀티 스레드를 선택하여, 자원 활용의 효율성을 높였습니다. 시스템의 특성을 고려하여 멀티 프로세스/멀티 스레드를 선택하는 것이 중요합니다.



<br/><br/>



**출처** 

https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html

https://charlezz.medium.com/process%EC%99%80-thread-%EC%9D%B4%EC%95%BC%EA%B8%B0-5b96d0d43e37

https://www.youtube.com/watch?v=DmZnOg5Ced8 

https://velog.io/@jacob0122/프로세스-스레드

https://velog.io/@yewon-july/Process-vs-Thread

https://d2.naver.com/helloworld/2922312

https://deveun.tistory.com/entry/OS-인터넷익스플로어와-크롬에서-멀티탭-기능-구현-차이
