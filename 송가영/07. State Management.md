
## 🔸 State란?
State는 컴포넌트 안에서 관리되는 변경 가능한 데이터 저장소입니다.

State는 크게 몇몇 컴포넌트에 국한되어 영향을 주는 지역 상태와 많은 컴포넌트에 영향을 주는 전역 상태로 나눌 수 있습니다. 

<br/>

## 🔸 State Management의 필요성
리액트는 단방향 데이터 바인딩을 지원하기 때문에, 부모에서 자식으로만 데이터를 전달할 수 있습니다. 데이터가 필요할 경우엔 하위 컴포넌트로 prop을 넘겨 해당 컴포넌트까지 전달되도록 Prop Drilling을 합니다. 

어플리케이션 규모가 커지면 Prop Drilling도 많아지게 되고, prop을 추적하고 관리하기 어려워집니다. 그래서 각 어플리케이션에 알맞는 상태관리 툴을 선택해 사용하는 것이 중요합니다.


<br/>
Prop Drilling이란?

props를 오직 하위 컴포넌트로 전달하는 용도로만 쓰이는 컴포넌트를 거쳐 다른 컴포넌트로 데이터를 전달하는 과정이다.

[상위 컴포넌트 > 중간 컴포넌트 > 중간 컴포넌트 ... > 타켓 컴포넌트] 

<br/>

## 🔸 State Management 역사
기존의 UI 상태 관리는 MVC 패턴을 사용했습니다. 

MVC 패턴에서는 모델 상태가 변경되면 뷰가 바뀌고, 뷰에서 변경이 일어나면 모델 상태가 바뀌며, 컨트롤러가 이를 조작합니다. 
MVC 패턴은 양방향 데이터 흐름을 가지고 있기 때문에 Model과 View의 개수가 많아지면 아래와 같이 복잡도가 증가합니다.  
<p align="center">
<img src="https://user-images.githubusercontent.com/17793440/163671515-f43315b9-be10-41f2-a177-b38e38472cb7.png"/>

  </p>

실제로 페이스북에서 읽지 않은 채팅 개수를 표시할 때 이 복잡도 때문에 고생을 한 적이 있습니다. 
채팅을 읽었으면 알림이 없어져야 하는데 없어지지 않았고, 처음에 사라졌다고 해도 몇 분뒤에 알림이 다시 표시되는 에러가 있었습니다. 
페이스북이 찾은 근본적인 문제점은 어플리케이션에서의 데이터 흐름이었습니다. 
해결책으로 데이터가 단방향으로만 흐르고, 새로운 데이터를 넣으면 처음부터 흐름이 다시 시작되는 방식인 Flux 패턴을 발표하게 됩니다.



**Flux 패턴**

Flux 패턴은 단방향으로 데이터가 진행되며, 상태의 전이 현상(뷰와 모델 사이의 데이터 변경이 연결된 수많은 곳을 따라 변경되는 현상)을 없애주고 예층 가능하다는 특징이 있습니다.

<img src="https://user-images.githubusercontent.com/17793440/163671536-791e92d4-5645-4555-8f87-6fda7cf32d42.png" align="center"/>

- Action 

  어플리케이션의 상태를 변경하거나 뷰를 업데이트 할때 액션을 발생시킨다.

- Dispatcher

  액션이 넘어오면 스토어에 액션을 보내며, 이 처리는 동기적으로 실행된다.

- Store

  어플리케이션 내의 모든 상태와 그와 관련된 로직을 가지고 있다. 모든 상태 변경은 반드시 스토어에 의해 결정되어야 하며, 상태 변경을 위한 요청을 스토어에 직접 보낼 수는 없다.

- View

  뷰는 상태를 가져와 유저에게 보여주고, 입력받을 화면을 렌더링하는 역할을 맡는다. 
  
  <br/>

## 🔸 State Management 라이브러리
뷰 라이브러리의 발전과 함께 상태가 복잡한 어플리케이션들이 생겨났고, 고도화된 전역 상태 관리에 대한 필요성이 생겨났습니다. 

