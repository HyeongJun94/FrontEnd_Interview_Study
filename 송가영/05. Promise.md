## 🔸 Promise란?

비동기 처리에 사용되는 객체로, 콜백 지옥 문제를 해결하기 위해 ES2015에 공식적으로 추가되었습니다.

 

- 비동기 처리란?

특정 코드의 연산이 끝날 때까지 기다려주지 않고 나머지 코드를 먼저 실행하는 것. 

 

- 콜백 지옥이란?

비동기적 처리를 위해 콜백 함수를 반복해서 사용하는 것. 가독성이 떨어짐.

 

## 🔸 Promise 생성

new Promise 메서드를 통해 Promise를 생성할 수 있으며, 생성할 때 콜백 함수를 선언할 수 있습니다.

콜백 함수의 인자는 resolve, reject 입니다.
```javascript
const getData = new Promise((resolve, reject) =>{
        console.log('promise는 생성하면 바로 실행됨');
    	let userData = '홍길동 20';
    	resolve(userData);
    });


getData
  .then(data => {console.log(data)})
  .catch(err => {console.log(err)});
 
```
## 🔸 Promise의 상태 

Promise는 대기, 이행, 실패 중 하나의 상태를 가집니다.

 

**대기(Pending)**

연산이 수행 중.

new Promise 메서드를 호출하면 대기 상태가 됩니다. 

 

**이행(Fulfilled)**

연산이 성공적으로 완료됨.

콜백 함수의 인자 resolve를 실행하면 이행 상태가 됩니다.

이행 상태가 되면 then을 이용하여 처리 결과 값을 받을 수 있습니다. 

 

**실패(Rejected)**

연산이 실패함.

콜백 함수의 인자 reject를 실행하면 실패 상태가 됩니다.

실패 상태가 되면 catch를 이용하여 실패한 이유를 받을 수 있습니다.

<p align="center">
<img src="https://user-images.githubusercontent.com/17793440/161422942-5ad5a465-5067-4ab8-ac1d-854db34c21d9.png"/>
</p>

 

## 🔸 Promise 활용
```javascript
//1. Producer
const promise = new Promise((resolve, reject) =>{
	setTimeout(() => {
    	resolve('Hi');
        //reject(new Error('no network'));
    }, 2000); 
});

//2. Consumers : then, catch, finally
promise
    .then((value) =>{
        console.log(value);
    })
    .catch(error => {
        console.log(error);
    });
    .finally(() => {
        console.log('finally');
    });
 ```

**Chaining**

이전 단계 비동기 작업이 성공하고 나서 그 결과 값을 이용하여 다음 비동기 작업을 실행해야 할 때, promise chaining을 이용할 수 있습니다.
```javascript
doSomething(function(result) {
  doSomethingElse(result, function(newResult) {
    doThirdThing(newResult, function(finalResult) {
      console.log('Got the final result: ' + finalResult);
    }, failureCallback);
  }, failureCallback);
}, failureCallback);
 
```
```javascript
doSomething()
.then(result => doSomethingElse(result))
.then(newResult => doThirdThing(newResult))
.then(finalResult => {
  console.log(`Got the final result: ${finalResult}`);
})
.catch(failureCallback);
```
then() 함수가 새로운 promise를 반환하기 때문에 chaining이 가능하며, 다음 promise에 값을 전달하고 싶으면 반환 값을 설정해야 합니다.

 
<br/>
 

**Chaining after catch**

chain에서 작업이 실패한 후에도 새로운 작업을 수행하는 것이 가능합니다.
```javascript
new Promise((resolve, reject) => {
    console.log('Initial');

    resolve();
})
.then(() => {
    throw new Error('Something failed');

    console.log('Do this');
})
.catch(() => {
    console.log('Do that');
})
.then(() => {
    console.log('Do this, whatever happened before');
});
```

출력결과  
Initial   
Do that  
Do this, whatever happened before  
