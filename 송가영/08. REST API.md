REST API란 REST 제약조건을 지킨 API를 말합니다.

먼저 REST란 무엇인지 알아보도록 하겠습니다.

## 🔸 REST 등장 배경
REST는 Representational State Tranfer의 약자로, 로이 필딩(Roy Fielding)이 2000년에 박사학위 논문에서 최초로 소개되었습니다. 로이 필딩은 HTTP/1.0, HTTP/1.1 주요 저자 중 한 명으로, 웹을 망가뜨리지 않으면서 HTTP를 적용하기 위한 방법에 대해 고민하였다고 합니다. 그래서 HTTP Object Model을 고안하게 되고, 이것이 후에 REST로 불리게 됩니다. 

로이 필딩은 REST를 분산형 하이퍼미디어 시스템(예 : 웹)을 위한 아키텍처 스타일이라고 정의하였습니다.

<br/>

## 🔸 API 등장과 REST (SOAP vs REST)
인터넷 상에서 API가 만들어지기 시작하면서, 1998년 Microsoft에서 XML-RPC라고 하는 원격으로 단일 시스템의 메서드를 호출할 수 있는 프로토콜(SOAP)을 만듭니다. 그리고 2000년 Salesforce라는 회사에서 SOAP를 사용한 API를 공개하였는데, 사용방법이 복잡하다 보니 잘 사용되지 않게 됩니다. 

이후 flickr라는 회사에서는 SOAP과 REST를 이용한 여러 형태의 API를 공개합니다. 사람들은 이 API를 보고 REST가 SOAP에 비해 단순하고, 규칙이 적으며 쉽다고 생각하게 되며 REST의 인기가 급상승하게 됩니다.

<br/>


## 🔸 REST 제약 조건
1. Client–server architecture
2. Statelessness
3. Cacheability
4. Layered system
5. Uniform interface
6. Code on demand (optional)

**Client–server architecture**

 클라이언트는 유저와 관련된 처리를, 서버는 REST API를 제공함으로써 각각의 역할이 확실하게 구별된다. 따라서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어듭니다.



**Statelessness**

작업을 위한 상태 정보를 따로 저장하고 관리하지 않습니다. API 서버는 들어오는 요청만을 단순히 처리하면 됩니다. 따라서 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해집니다.

**Cacheability**

REST의 가장 큰 특징 중 하나는 HTTP라는 기존 웹 표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용할 수 있다는 것입니다. HTTP 프로토콜 표준에서 사용하는 Last-Modified 태그나 E-Tag 등을 이용하여 캐싱 구현이 가능합니다.

 

**Layered system**

보안, 로드 밸런싱, 암호화 계층을 추가하여 구조상의 유연성을 줄 수 있고, Proxy, gateway 같은 네트워크 기반의 중간 매체를 사용할 수 있습니다.

 

**Uniform interface**

URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행합니다.

REST API 메시지만 보고도 이를 쉽게 이해 할 수 있어야 하며, 애플리케이션의 상태는 Hyperlink를 이용해 전이되어야 합니다.

 

**Code on demand (optional)**

서버는 클라이언트가 실행시킬 수 있는 로직(javascript)을 전송하여 기능을 확장시킬 수 있습니다.

<br/>

## 🔸 HTTP와 REST
HTTP는 REST 아키텍처가 반영된 프로토콜이기 때문에, 제약 조건 중에 HTTP의 특징과 겹치는 부분이 많이 있습니다.

REST는 HTTP/1.1로 넘어오면서 반영되었고, HTTP는 REST 아키텍처 스타일이 반영되었기 때문에 HTTP를 이용하여 REST 제약 조건이 잘 지켜진 RESTful 시스템을 쉽게 만들 수 있습니다. 


<br/>
 
## 🔸 REST API 디자인 가이드
REST API 설계 시 가장 중요한 것은 2가지로 요약할 수 있습니다.

1. URI는 정보의 자원을 표현해야 한다.

2. 자원에 대한 행위는 HTTP Method로 표현한다.

Method	역할
POST	POST를 통해 해당 URI를 요청하면 리소스를 생성합니다.
GET	GET를 통해 해당 리소스를 조회합니다. 
PUT	PUT를 통해 해당 리소스를 수정합니다.
PATCH	PATCH를 통해 해당 리소스의 부분을 수정합니다.
DELETE	DELETE를 통해 리소스를 삭제합니다.


**URI 설계시 주의할 점**

1) 슬래시 구분자(/)는 계층 관계를 나타내는 데 사용

2) URI 마지막 문자로 슬래시(/)를 포함하지 않는다.

3) 하이픈(-)은 URI 가독성을 높이는 데 사용

4) 밑줄(_)은 URI에 사용하지 않는다.

5) URI 경로에는 소문자가 적합하다.

    : URI 경로에 대문자 사용은 피하도록 해야 합니다. 대소문자에 따라 다른 리소스로 인식하게 되기 때문입니다.

6) 파일 확장자는 URI에 포함시키지 않는다.

<br/>

## 🔸 HTTP 응답 상태 코드
|상태코드| |
|-------|-------------------------------------------------------------------------------------------|
|200	|클라이언트의 요청을 정상적으로 수행함|
|201	|클라이언트가 어떠한 리소스 생성을 요청, 해당 리소스가 성공적으로 생성됨(POST를 통한 리소스 생성 작업 시)|


|상태코드| |
|-------|-------------------------------------------------------------------------------------------|
|400	|클라이언트의 요청이 부적절 할 경우 사용하는 응답 코드|
|401	|클라이언트가 인증되지 않은 상태에서 보호된 리소스를 요청했을 때 사용하는 응답 코드|
||(로그인 하지 않은 유저가 로그인 했을 때, 요청 가능한 리소스를 요청했을 때)|
|403	|유저 인증상태와 관계 없이 응답하고 싶지 않은 리소스를 클라이언트가 요청했을 때 사용하는 응답 코드|
||(403 보다는 400이나 404를 사용할 것을 권고. 403 자체가 리소스가 존재한다는 뜻이기 때문에)|
|405|	클라이언트가 요청한 리소스에서는 사용 불가능한 Method를 이용했을 경우 사용하는 응답 코드|


|상태코드| |
|-------|-------------------------------------------------------------------------------------------|
|301	|클라이언트가 요청한 리소스에 대한 URI가 변경 되었을 때 사용하는 응답 코드|
||(응답 시 Location header에 변경된 URI를 적어 줘야 합니다.)|
|500	|서버에 문제가 있을 경우 사용하는 응답 코드|


출처 

https://velog.io/@lehdqlsl/Spring-boot-HTTP-API-%EB%A7%8C%EB%93%A4%EA%B8%B0-Hello-World

https://meetup.toast.com/posts/92

https://www.youtube.com/watch?v=RP_f5dMoHFc&t=2s 

https://martinfowler.com/articles/richardsonMaturityModel.html

https://docs.microsoft.com/ko-kr/azure/architecture/best-practices/api-design



